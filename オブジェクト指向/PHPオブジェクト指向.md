###### tags: `PHP`

# オブジェクト指向とは？

- オブジェクト指向は**考え方**のことで、プログラムを設計する**設計手法：アーキテクチャ**のことをいう
- その考えを用いてプログラムを書いていくことで、**保守性が高く**なる
- 保守性が高いとは、何か仕様変更が合った際にバグを生み出しにくかったり、誰が見てもわかりやすいコードであったりすることをいう
- オブジェクト思考は、プログラムという**仮想世界**を**現実世界のオブジェクト：実体**に照らし合わせて考える

# オブジェクト指向での作りかた

1. クラスを作る
2. クラスの中にコンストラクタを作る（無くても良い）
   - インスタンス生成時に、プロパティ（HP や MP など）になにか値を入れたい場合には使用する
3. クラスを元にインスタンスを作る（インスタンス化）

# インスタンスのイメージ

- インスタンスは**大きな変数**のようなもの
- 変数を定義したら値を入れられる用になるが、実際にその値は PC のメモリの中に格納される
- インスタンスも同様で、インスタンスを新しく生成したら**その領域がメモリに確保**される

# クラス

- オブジェクトを生成する際の設計図のこと
- **プロパティ**と呼ばれる変数を持つことが出来る
- インスタンス生成時に、そのプロパティに初期値を入れることでクラスという設計図から各々に違うインスタンスが生成することが出来る
- `$this`は**自分自身を意味し**、クラスから生成したインスタンス自身を指す
- インスタンスの生成は**new 演算子**を使用して生成する
- インスタンス生成時に初期値を設定したい場合は、`new Monster($name, $hp, $img)`などのように引数を設定する
- 引数を設定するとインスタンス生成時に必ず**コンストラクタ関数**が呼ばれ、プロパティに引数の値がセットするなど、何かしらの処理が行われる
- コンストラクタのような特別なメソッドを**マジックメソッド**と呼ぶ
- クラス名は他のメソッドなどと区別できるように、**頭文字は大文字にするのが習わし**

# プロパティ

- 定義しただけだと初期値に**null**が入る
- **null**を入れたくない場合は、空文字などで初期化する
- `$this->name`で、自分自身のプロパティにアクセス出来る
- `$this->name = $name`のようにプロパティに値を代入することが出来る

# コンストラクタ

- インスタンスを生成する際に何か初期化処理を行いたい場合に使用する
- プロパティに値をセットしたい、メソッドを実行しておきたいなど
- コンストラクター関数に引数を設定すると、インスタンス生成時にプロパティに初期値をセットすることができる
- ただし、インスタンス生成時に引数に対応する値を渡してやらないとエラーになる

```php
// 例

class MyClass
{
    protected $name;
    protected $age;
    protected $body;

    public __constructor($name, $age, $body)
    {
        $this->name = $name;
        $this->age = $age;
        $this->body = $body;
    }
}

// インスタンス生成
$instance = new MyClass('bob', 19, 'MukiMuki');
// コンストラクタに引数を設定している場合はエラーになる
$instance = new MyClass();
```

# アクセス権とカプセル化

## public って何？

- **アクセス権（アクセス修飾子）**と呼ばれ、クラス内のメソッドやプロパティに付与して、外からアクセスできる**範囲を制限**できる
- プロパティやメソッドには必ずつけなければならない
- プロパティにつけない**構文エラー**になる
- メソッドに付けないと**public を付けたとみなされる**

## アクセス権の違い

1. private
   - そのクラスからしかアクセス出来ない
2. protected
   - そのクラスと、サブクラスからしかアクセスできない
   - サブクラスとは**継承先のクラス**のこと
3. public
   - どこからでもアクセス出来る

### 公式リファレンスより例文

```php
<?php
/**
 * MyClass の定義
 */
class MyClass
{
    public $public = 'Public';
    protected $protected = 'Protected';
    private $private = 'Private';

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj = new MyClass();
echo $obj->public; // 動作します
echo $obj->protected; // Fatal エラー
echo $obj->private; // Fatal エラー

$obj->printHello(); // Public、Protected そして Private を表示します

// $thisで呼び出されているので、それぞれのアクセス権でも呼び出せる
// $thisは自分自身（クラス自身）を意味するので、全てのアクセス権でもプロパティにアクセス出来る
```

## カプセル化

- 先述のアクセス権により、外側からプロパティに対してアクセスできなくすることによって**誤って値が代入されて処理が進んでしまうことを防ぐ**ことを**カプセル化**という
- 途中で誤って値が代入されると思わぬバグを生み出し、特定に苦労する
- 実際のプロパティの操作は**プロパティを操作できるようのメソッド**を用意して、そのメソッドを経由して外側からもアクセス出来るようにして操作を行う
- このときの、**プロパティを取得する専門のメソッドをゲッター、プロパティの値をセットする専用のメソッドをセッター**と呼ぶ

### セッターのメリット

- 直接値を渡すのではなく、何かしらの**バリデーションを挟むことができる**

```php
class Monster {

// プロパティ
protected $name; // 定義しただけだとnullが入る
protected $hp; //この辺が空だから今はエラーが出ている？？ 2019-08-12 05:06:30
protected $img;
protected $attack = ''; // nullを入れたくない場合、空文字などで初期化する

// ~~~ 中略 ~~~

public function setHp($num){
    // セッターを使うことで、直接代入させずにバリデーションチェックを行ってから代入させることができる
    // filter_varは値に対して色々なパターンのバリデーションを行える便利関数
    // FILTER_VALIDATE_INT は整数値であるかどうか判定する（小数点が交じると困るので）
    $this->hp = filter_var($num, FILTER_VALIDATE_INT);
}
```

# 継承

- クラスには継承という仕組みがあり、既に存在するクラスを元に**さらに拡張したクラス**を作る仕組みのこと
- ほとんど同じだけど、メソッドやプロパティなど少し変更したい時に使える
- 継承を使うことで**継承元のクラスで定義したプロパティやメソッド**を、**継承さきで定義していなくても使うことができる**
- しかし、**private がついているものは継承されない**
- 継承する想定のクラスだが、**外部には非公開したい**場合には**protected**を使う
- 継承元の親クラスを**スーパークラス**
- 継承先の子クラスを**サブクラス**
- インスタンスが**どのクラスから作られたインスタンスか**を確認するには**instanceof**で判定してやる
- **このオブジェクトは何の情報を持ち、何の動きができるか**と、オブジェクト同士が相手を意識せずにただ呼ぶだけで良いような設計を行う（疎結合）

## 根渡しと参照渡し

### 根渡し

- 根渡しとは、**変数の値をそのままコピーして渡す**こと
- コピーした変数を関数の中で、値を変えたりしても**元の変数には影響がない**

### 参照渡し

- 関数の引数に`&`を付けることで参照渡しになる
- 参照渡しでは**変数の値を格納しているメモリの番地を渡す（リファレンス渡しとも言う）**
- メモリの番地を渡してその中身を操作するので、中身を変更すると**元の変数にも影響がある**

```php
// 根渡し
function myFunc1($obj){
    $obj = 5;
}

// 引数に&をつけると参照渡しになる
function myFunc2(&$obj){
    $obj = 5;
}

$a = 1;

myFunc($a);
echo $a; // 1

myFunc2($a);
echo $a; // 5 <---★ 元の変数の値も変更される
```

# インスタンスも参照渡し

```php
class Monster {
    public $hp = 5;
}

function myFunc($obj){
    $obj->hp = 100;
}

// インスタンス生成
$obj = new Monster();

// とりあえずプロパティを表示
echo $obj->hp; // 5

// インスタンスは参照渡しなので、関数内で値が変更されると元のインスタンス自体にも影響がある
myFunc($obj);
echo $obj->hp; // 100
```

# 継承の使い方

```php
class クラス名 extends 親クラス名 {

    // 継承することで親クラスのプロパティやメソッドを引き継げる

}
```

# オーバーロード

- 継承クラスにおいて、**親クラスのメソッドを上書きする仕組み**のこと
- **親クラスのメソッドに追加機能を持たせたい場合**や親クラスのメソッドの**機能を殺したい**場合に使用する

## 使い方

- 親クラスと同じメソッド名を作成するだけ
- 親クラスのメソッドを、子クラスでも使用したい場合は`parent::`で親クラスのメソッドを呼んであげる

```php
// 例
parent::attack($targetObj);
```

# 静的メンバー

- インスタンスを生成しなくても、クラスのプロパティやメソッド（メンバ）にアクセスできる仕組み
- インスタンスを生成せずともすぐに使いたいものは**静的メンバーに登録しておく**
- 静的にしたいメンバーには`public static`を付ける
- インスタンス生成時にはクラスで定義したプロパティやメソッドが丸々コピーされるイメージだが、静的メンバーに登録したものはインスタンス生成時にインスタンスに受け継がれない（作成されない）
- インスタンス生成時には、クラスで定義したメンバー分の**メモリ：ヒープメモリ**が確保される
- **ヒープメモリ**はアプリケーションで使うメモリ領域の一つで、**メモリの中でアプリケーションが使う部分の領域のこと**をヒープメモリと呼ぶ
- 静的メンバーはインスタンスを生成してもコピーされないので、その分メモリを使わない
- 静的メンバーを呼び出すには`インスタンス名->`は使えない

## 使い方

```php
// 定義方法
public static プロパティ名
public static function メソッド名

// クラス外での呼び出し方
ClassName::$プロパティ名
ClassName::メソッド名()

// クラス内での呼び出し方法
self::$プロパティ名
self::メソッド名()
```

# クラス定数

- **クラス内に定義する定数**のことで、`define`を使った定数はグローバル定数と変わらないが、**そのクラスに属したプロパティの定数**という意味が伝わる
- 主に**クラス内の設定値**に使い、クラス定数は**静的メンバーと同じ扱いになる**
- 値をベタ書きすると後々修正する際に全て修正する必要があり、修正漏れがあるとバグが発生するためクラス定数を積極的に使うと良い

## 使い方

```php
// 定義方法
const 定数名 = 値;

// クラス外での呼び出し方法
ClassName::定数名

// クラス内での呼び出し方法
self::定数名
```

# 抽象クラス

- **直接インスタンスを生成できないクラス**のことで、**必ず継承して使用するクラス**ということ
- 抽象クラスには**抽象メソッド**が定義できる
- 抽象メソッドとは**処理内容を持たずに名前だけ定義されたメソッド**
- 抽象メソッドでは**処理内容をもたないので、{}を付けない**
- 抽象メソッドは**継承先のクラスで必ずオーバーライドする**必要があり、そうしないとエラーになる
- 抽象クラスでは継承先のクラスに対して、**特定のメソッドの実装を強制する事**ができ、抽象クラスでは普通のプロパティやメソッドも定義できる
- 抽象メソッドと普通のメソッドを作成しておけば、継承先のクラスで**カスタマイズするメソッドと普通のメソッド**も利用できるクラスだ出来上がる
- 抽象クラスはクラス同士で共通化できるところを抜き出したもの

## 使い方

```php
abstract class ClassName
{
    // 抽象メソッドの定義方法
    // アクセス権は必ず public になる
    // 処理内容をもたないので {} を付けない
    abstract public function method();
}

// 継承して使う
class Class extends ClassName
{
    //
}
```

# インターフェース

- 抽象メソッドのみ定義可能なクラスみたいなもの
- 抽象クラスでは普通のメソッドも定義できたが、**インターフェースでは抽象メソッドしか定義できない**
- インターフェースでは**継承ではなく：実装**と呼ぶ
- 実装には`implements`を使う
- **必ず実装してもらうためのクラスのテンプレート**としてインターフェースを使う
  - その理由として、クラス内で別クラスのプロパティやメソッドにアクセスする際には、**そのメンバが必ず実装されてあることが前提**となるため、そのクラスが**実装漏れしていればエラーになる**ため

## 使い方

- 定義できるのは**抽象メソッドのみ**
- 抽象メソッドだが**abstract**はいらない
- アクセス修飾子には**public しか指定できない**
- 直接インスタンスの生成はできない
- インタフェースは**多重継承できる**

```php
interface ClassName
{
    // アクセス権は必ず public になる
    public function method();
}

// 継承する
class Class implements interface1, interface2
{

}
```

# ポリフォーフィズム

- ポリフォーフィズムとは多態性を意味し、オブジェクト指向能メリットの一つとしてよく言われる
- ポリフォーフィズムは**異なる動作を同じ操作で実現すること**
- PHP の場合**クラスは異なっても同じ名前のメソッドで色々な動きを実現させる事**を言い、それには**インターフェースが絡んでくる**
- イメージとして家電製品の洗濯機が挙げられ、ボタンを押しただけで**色々な異なるモードを実行できる**ことがポリフォーフィズムの機能と被ってくる
- Monster クラス内のメソッドでは、History クラスの`setメソッド`を**必ず持っている前提**で処理をしているため、その**前提を保証するために History クラスがインターフェースを実装する**、と言うもの
- 同じメソッドがある前提で処理をするため、呼び出すクラス（インスタンス）にメソッドが必ずないとエラーになってしまう
- インターフェースや抽象クラスで、抽象メソッドとする理由は**必ず存在しなければならないメソッドだが、中身は継承先のクラスで好きにして良い**と言うことを強制させるためのもの

# 名前空間

- PHP5.3 から出来た仕組みで、クラスをディレクトリ構造のように階層的に分類できる仕組みのこと
- ディレクトリと同じように\*\*違う名前空間で同じ名前のクラスを定義出来るようになる
- 以前はこの機能は使えなかったので、既存のクラス名にプレフィックスをつけ長くしたものが多かった

## 使い方

```php
// 定義方法
<?php

namespace Auth;
class Login
{

}

// フルパスでの使い方
$login = new \Auth\Login();

// 名前空間を宣言して使う方法
use Auth;
$login = new Login();

// 同じクラス名を使う場合（別名を付与している）
use Auth\Login as AuthLogin;
use Db\Login as DbLogin;
$login = new AuthLogin();
```

## グローバル空間とクラス名

- 名前空間を指定した際に、**バックスラッシュをつけたときはグローバル空間のクラスを指定することになる**

```php
use Auth;

$auth = new \Login(); // \Loginのクラスを指定

$auth = new Login(); // \Auth\Loginのクラスを指定
```

## 名前空間では Exception に注意！

- 下記のような例では、**Exception はグローバル空間**

```php
<?php

namespace Auth;

class Login
{
    try{

        // 処理

    }catch(Exception $e){ // 名前空間を指定しているので \Auth\Exception を呼び出していることになる（ \Exceptionとしないとクラスが見つからずエラーになる）

        // 処理

    }
}
```
